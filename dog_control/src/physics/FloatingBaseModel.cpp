#include "dog_control/physics/FloatingBaseModel.h"

#include <cassert>
#include <iostream>

namespace dog_control
{

namespace physics
{

namespace spatial
{

int FloatingBaseModel::AddLink(const NodeDescription &node, int parent)
{
    // the link's parent must have a smaller id
    assert(static_cast<unsigned>(parent) <= node_description_.size());

    const int link_id = node_description_.size() + 1;

    // only the first link could have a floating joint
    assert((link_id != 1) xor (node.joint_type == floating));
    assert((link_id != 1) xor (parent == 0));

    node_description_.push_back(node);
    parent_.push_back(parent - 1);

    return link_id;
}

int FloatingBaseModel::AddEndEffector(int link_id,
                                      const Eigen::Vector3d &ee_local_pos)
{
    assert(static_cast<unsigned>(link_id - 1) < node_description_.size());

    const int ee_id = ee_local_pos.size();

    ee_info_.push_back({ee_local_pos, link_id - 1});

    return ee_id;
}

void FloatingBaseModel::SetJointMotionState(
        const FloatingBaseJointState &stat)
{
    // exclude the floating base
    const size_t joint_size = node_description_.size() - 1;

    assert(stat.q.size() == joint_size);
    assert(stat.dq.size() == joint_size);

    js_ = stat;
    kinematics_updated_ = false;
}

void FloatingBaseModel::ForwardKinematics()
{
    if(kinematics_updated_)
        return;

    const size_t node_cnt = node_description_.size();
    v_.resize(node_cnt);
    X0_.resize(node_cnt);

    X0_[0] = BuildTransform(js_.base_trans, js_.base_rot);
    v_[0].topRows(3) = js_.base_rot_vel;
    v_[0].bottomRows(3) = js_.base_linear_vel;

    for(size_t i = 1; i < node_cnt; i++)
    {
        // X0_[i] is the multiplication of three parts:
        // the transform from fixed base to its parent (X0_[parent_[i]]);
        // transform from its parent to the joint;
        // and the transform generated by joint motion (X_joint).
        const SMat X_joint
                = BuildJointTransform(node_description_[i].joint_axis,
                                      node_description_[i].joint_type,
                                      js_.q[i - 1]);
        const SMat X_parent = X_joint * node_description_[i].X_parent;
        v_[i] = X_parent * v_[parent_[i]]
                + node_description_[i].joint_axis * js_.dq[i - 1];
        X0_[i] = X_parent * X0_[parent_[i]];
    }
}

Eigen::Vector3d FloatingBaseModel::EEPos(int ee_id) const
{
    assert(static_cast<unsigned>(ee_id) < ee_info_.size());

    const EndEffectorInfo& ee = ee_info_[ee_id];

    return PointTf(MotionTfInverse(X0_[ee.ee_link_id]),
                   ee.ee_local_pos);
}

Eigen::Vector3d FloatingBaseModel::EEVel(int ee_id) const
{
    assert(static_cast<unsigned>(ee_id) < ee_info_.size());

    const EndEffectorInfo& ee = ee_info_[ee_id];

    return X0_[ee.ee_link_id].topLeftCorner(3, 3).transpose()
            * LinearVel(v_[ee.ee_link_id], ee.ee_local_pos);
}

void FloatingBaseModel::DemoInfo()
{
    std::cout << "floating base info" << std::endl;

    for(size_t i = 0; i < node_description_.size(); i++)
    {
        std::cout << "--------------------------------" << std::endl;
        std::cout << "link " << i + 1 << std::endl;
        std::cout << "tf: " << std::endl
                  << X0_[i] << std::endl;
        std::cout << "vel: " << std::endl
                  << v_[i] << std::endl;
    }
}

} /* spatial */

} /* physics */

} /* dog_control */
